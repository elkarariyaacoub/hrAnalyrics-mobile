"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/wheel-gestures";
exports.ids = ["vendor-chunks/wheel-gestures"];
exports.modules = {

/***/ "(ssr)/./node_modules/wheel-gestures/dist/wheel-gestures.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/wheel-gestures/dist/wheel-gestures.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WheelGestures: () => (/* binding */ WheelGestures),\n/* harmony export */   absMax: () => (/* binding */ absMax),\n/* harmony export */   addVectors: () => (/* binding */ addVectors),\n/* harmony export */   average: () => (/* binding */ average),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   configDefaults: () => (/* binding */ configDefaults),\n/* harmony export */   deepFreeze: () => (/* binding */ deepFreeze),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   lastOf: () => (/* binding */ lastOf),\n/* harmony export */   projection: () => (/* binding */ projection)\n/* harmony export */ });\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar DECAY = 0.996;\n/**\r\n * movement projection based on velocity\r\n * @param velocityPxMs\r\n * @param decay\r\n */\n\nvar projection = function projection(velocityPxMs, decay) {\n  if (decay === void 0) {\n    decay = DECAY;\n  }\n\n  return velocityPxMs * decay / (1 - decay);\n};\n\nfunction lastOf(array) {\n  return array[array.length - 1];\n}\nfunction average(numbers) {\n  return numbers.reduce(function (a, b) {\n    return a + b;\n  }) / numbers.length;\n}\nvar clamp = function clamp(value, min, max) {\n  return Math.min(Math.max(min, value), max);\n};\nfunction addVectors(v1, v2) {\n  if (v1.length !== v2.length) {\n    throw new Error('vectors must be same length');\n  }\n\n  return v1.map(function (val, i) {\n    return val + v2[i];\n  });\n}\nfunction absMax(numbers) {\n  return Math.max.apply(Math, numbers.map(Math.abs));\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction deepFreeze(o) {\n  Object.freeze(o);\n  Object.values(o).forEach(function (value) {\n    if (value !== null && typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  });\n  return o;\n}\n\nfunction EventBus() {\n  var listeners = {};\n\n  function on(type, listener) {\n    listeners[type] = (listeners[type] || []).concat(listener);\n    return function () {\n      return off(type, listener);\n    };\n  }\n\n  function off(type, listener) {\n    listeners[type] = (listeners[type] || []).filter(function (l) {\n      return l !== listener;\n    });\n  }\n\n  function dispatch(type, data) {\n    if (!(type in listeners)) return;\n    listeners[type].forEach(function (l) {\n      return l(data);\n    });\n  }\n\n  return deepFreeze({\n    on: on,\n    off: off,\n    dispatch: dispatch\n  });\n}\n\nfunction WheelTargetObserver(eventListener) {\n  var targets = []; // add event listener to target element\n\n  var observe = function observe(target) {\n    target.addEventListener('wheel', eventListener, {\n      passive: false\n    });\n    targets.push(target);\n    return function () {\n      return unobserve(target);\n    };\n  }; /// remove event listener from target element\n\n\n  var unobserve = function unobserve(target) {\n    target.removeEventListener('wheel', eventListener);\n    targets = targets.filter(function (t) {\n      return t !== target;\n    });\n  }; // stops watching all of its target elements for visibility changes.\n\n\n  var disconnect = function disconnect() {\n    targets.forEach(unobserve);\n  };\n\n  return deepFreeze({\n    observe: observe,\n    unobserve: unobserve,\n    disconnect: disconnect\n  });\n}\n\nvar LINE_HEIGHT = 16 * 1.125;\nvar PAGE_HEIGHT = typeof window !== 'undefined' && window.innerHeight || 800;\nvar DELTA_MODE_UNIT = [1, LINE_HEIGHT, PAGE_HEIGHT];\nfunction normalizeWheel(e) {\n  var deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode];\n  var deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode];\n  var deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode];\n  return {\n    timeStamp: e.timeStamp,\n    axisDelta: [deltaX, deltaY, deltaZ]\n  };\n}\nvar reverseAll = [-1, -1, -1];\nfunction reverseAxisDeltaSign(wheel, reverseSign) {\n  if (!reverseSign) {\n    return wheel;\n  }\n\n  var multipliers = reverseSign === true ? reverseAll : reverseSign.map(function (shouldReverse) {\n    return shouldReverse ? -1 : 1;\n  });\n  return _extends({}, wheel, {\n    axisDelta: wheel.axisDelta.map(function (delta, i) {\n      return delta * multipliers[i];\n    })\n  });\n}\nvar DELTA_MAX_ABS = 700;\nvar clampAxisDelta = function clampAxisDelta(wheel) {\n  return _extends({}, wheel, {\n    axisDelta: wheel.axisDelta.map(function (delta) {\n      return clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS);\n    })\n  });\n};\n\nvar __DEV__ = \"development\" !== 'production';\nvar ACC_FACTOR_MIN = 0.6;\nvar ACC_FACTOR_MAX = 0.96;\nvar WHEELEVENTS_TO_MERGE = 2;\nvar WHEELEVENTS_TO_ANALAZE = 5;\n\nvar configDefaults = /*#__PURE__*/deepFreeze({\n  preventWheelAction: true,\n  reverseSign: [true, true, false]\n});\n\nvar WILL_END_TIMEOUT_DEFAULT = 400;\nfunction createWheelGesturesState() {\n  return {\n    isStarted: false,\n    isStartPublished: false,\n    isMomentum: false,\n    startTime: 0,\n    lastAbsDelta: Infinity,\n    axisMovement: [0, 0, 0],\n    axisVelocity: [0, 0, 0],\n    accelerationFactors: [],\n    scrollPoints: [],\n    scrollPointsToMerge: [],\n    willEndTimeout: WILL_END_TIMEOUT_DEFAULT\n  };\n}\n\nfunction WheelGestures(optionsParam) {\n  if (optionsParam === void 0) {\n    optionsParam = {};\n  }\n\n  var _EventBus = EventBus(),\n      on = _EventBus.on,\n      off = _EventBus.off,\n      dispatch = _EventBus.dispatch;\n\n  var config = configDefaults;\n  var state = createWheelGesturesState();\n  var currentEvent;\n  var negativeZeroFingerUpSpecialEvent = false;\n  var prevWheelEventState;\n\n  var feedWheel = function feedWheel(wheelEvents) {\n    if (Array.isArray(wheelEvents)) {\n      wheelEvents.forEach(function (wheelEvent) {\n        return processWheelEventData(wheelEvent);\n      });\n    } else {\n      processWheelEventData(wheelEvents);\n    }\n  };\n\n  var updateOptions = function updateOptions(newOptions) {\n    if (newOptions === void 0) {\n      newOptions = {};\n    }\n\n    if (Object.values(newOptions).some(function (option) {\n      return option === undefined || option === null;\n    })) {\n      __DEV__ && console.error('updateOptions ignored! undefined & null options not allowed');\n      return config;\n    }\n\n    return config = deepFreeze(_extends({}, configDefaults, config, newOptions));\n  };\n\n  var publishWheel = function publishWheel(additionalData) {\n    var wheelEventState = _extends({\n      event: currentEvent,\n      isStart: false,\n      isEnding: false,\n      isMomentumCancel: false,\n      isMomentum: state.isMomentum,\n      axisDelta: [0, 0, 0],\n      axisVelocity: state.axisVelocity,\n      axisMovement: state.axisMovement,\n\n      get axisMovementProjection() {\n        return addVectors(wheelEventState.axisMovement, wheelEventState.axisVelocity.map(function (velocity) {\n          return projection(velocity);\n        }));\n      }\n\n    }, additionalData);\n\n    dispatch('wheel', _extends({}, wheelEventState, {\n      previous: prevWheelEventState\n    })); // keep reference without previous, otherwise we would create a long chain\n\n    prevWheelEventState = wheelEventState;\n  }; // should prevent when there is mainly movement on the desired axis\n\n\n  var shouldPreventDefault = function shouldPreventDefault(deltaMaxAbs, axisDelta) {\n    var _config = config,\n        preventWheelAction = _config.preventWheelAction;\n    var deltaX = axisDelta[0],\n        deltaY = axisDelta[1],\n        deltaZ = axisDelta[2];\n    if (typeof preventWheelAction === 'boolean') return preventWheelAction;\n\n    switch (preventWheelAction) {\n      case 'x':\n        return Math.abs(deltaX) >= deltaMaxAbs;\n\n      case 'y':\n        return Math.abs(deltaY) >= deltaMaxAbs;\n\n      case 'z':\n        return Math.abs(deltaZ) >= deltaMaxAbs;\n\n      default:\n        __DEV__ && console.warn('unsupported preventWheelAction value: ' + preventWheelAction, 'warn');\n        return false;\n    }\n  };\n\n  var processWheelEventData = function processWheelEventData(wheelEvent) {\n    var _clampAxisDelta = clampAxisDelta(reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)),\n        axisDelta = _clampAxisDelta.axisDelta,\n        timeStamp = _clampAxisDelta.timeStamp;\n\n    var deltaMaxAbs = absMax(axisDelta);\n\n    if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) {\n      wheelEvent.preventDefault();\n    }\n\n    if (!state.isStarted) {\n      start();\n    } // check if user started scrolling again -> cancel\n    else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {\n        end(true);\n        start();\n      } // special finger up event on windows + blink\n\n\n    if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {\n      negativeZeroFingerUpSpecialEvent = true; // return -> zero delta event should not influence velocity\n\n      return;\n    }\n\n    currentEvent = wheelEvent;\n    state.axisMovement = addVectors(state.axisMovement, axisDelta);\n    state.lastAbsDelta = deltaMaxAbs;\n    state.scrollPointsToMerge.push({\n      axisDelta: axisDelta,\n      timeStamp: timeStamp\n    });\n    mergeScrollPointsCalcVelocity(); // only wheel event (move) and not start/end get the delta values\n\n    publishWheel({\n      axisDelta: axisDelta,\n      isStart: !state.isStartPublished\n    }); // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })\n    // publish start after velocity etc. have been updated\n\n    state.isStartPublished = true; // calc debounced end function, to recognize end of wheel event stream\n\n    willEnd();\n  };\n\n  var mergeScrollPointsCalcVelocity = function mergeScrollPointsCalcVelocity() {\n    if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {\n      state.scrollPoints.unshift({\n        axisDeltaSum: state.scrollPointsToMerge.map(function (b) {\n          return b.axisDelta;\n        }).reduce(addVectors),\n        timeStamp: average(state.scrollPointsToMerge.map(function (b) {\n          return b.timeStamp;\n        }))\n      }); // only update velocity after a merged scrollpoint was generated\n\n      updateVelocity(); // reset toMerge array\n\n      state.scrollPointsToMerge.length = 0; // after calculation of velocity only keep the most recent merged scrollPoint\n\n      state.scrollPoints.length = 1;\n\n      if (!state.isMomentum) {\n        detectMomentum();\n      }\n    } else if (!state.isStartPublished) {\n      updateStartVelocity();\n    }\n  };\n\n  var updateStartVelocity = function updateStartVelocity() {\n    state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map(function (d) {\n      return d / state.willEndTimeout;\n    });\n  };\n\n  var updateVelocity = function updateVelocity() {\n    // need to have two recent points to calc velocity\n    var _state$scrollPoints = state.scrollPoints,\n        latestScrollPoint = _state$scrollPoints[0],\n        prevScrollPoint = _state$scrollPoints[1];\n\n    if (!prevScrollPoint || !latestScrollPoint) {\n      return;\n    } // time delta\n\n\n    var deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp;\n\n    if (deltaTime <= 0) {\n      __DEV__ && console.warn('invalid deltaTime');\n      return;\n    } // calc the velocity per axes\n\n\n    var velocity = latestScrollPoint.axisDeltaSum.map(function (d) {\n      return d / deltaTime;\n    }); // calc the acceleration factor per axis\n\n    var accelerationFactor = velocity.map(function (v, i) {\n      return v / (state.axisVelocity[i] || 1);\n    });\n    state.axisVelocity = velocity;\n    state.accelerationFactors.push(accelerationFactor);\n    updateWillEndTimeout(deltaTime);\n  };\n\n  var updateWillEndTimeout = function updateWillEndTimeout(deltaTime) {\n    // use current time between events rounded up and increased by a bit as timeout\n    var newTimeout = Math.ceil(deltaTime / 10) * 10 * 1.2; // double the timeout, when momentum was not detected yet\n\n    if (!state.isMomentum) {\n      newTimeout = Math.max(100, newTimeout * 2);\n    }\n\n    state.willEndTimeout = Math.min(1000, Math.round(newTimeout));\n  };\n\n  var accelerationFactorInMomentumRange = function accelerationFactorInMomentumRange(accFactor) {\n    // when main axis is the the other one and there is no movement/change on the current one\n    if (accFactor === 0) return true;\n    return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN;\n  };\n\n  var detectMomentum = function detectMomentum() {\n    if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {\n      if (negativeZeroFingerUpSpecialEvent) {\n        negativeZeroFingerUpSpecialEvent = false;\n\n        if (absMax(state.axisVelocity) >= 0.2) {\n          recognizedMomentum();\n          return;\n        }\n      }\n\n      var recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1); // check recent acceleration / deceleration factors\n      // all recent need to match, if any did not match\n\n      var detectedMomentum = recentAccelerationFactors.every(function (accFac) {\n        // when both axis decelerate exactly in the same rate it is very likely caused by momentum\n        var sameAccFac = !!accFac.reduce(function (f1, f2) {\n          return f1 && f1 < 1 && f1 === f2 ? 1 : 0;\n        }); // check if acceleration factor is within momentum range\n\n        var bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length; // one the requirements must be fulfilled\n\n        return sameAccFac || bothAreInRangeOrZero;\n      });\n\n      if (detectedMomentum) {\n        recognizedMomentum();\n      } // only keep the most recent events\n\n\n      state.accelerationFactors = recentAccelerationFactors;\n    }\n  };\n\n  var recognizedMomentum = function recognizedMomentum() {\n    state.isMomentum = true;\n  };\n\n  var start = function start() {\n    state = createWheelGesturesState();\n    state.isStarted = true;\n    state.startTime = Date.now();\n    prevWheelEventState = undefined;\n    negativeZeroFingerUpSpecialEvent = false;\n  };\n\n  var willEnd = function () {\n    var willEndId;\n    return function () {\n      clearTimeout(willEndId);\n      willEndId = setTimeout(end, state.willEndTimeout);\n    };\n  }();\n\n  var end = function end(isMomentumCancel) {\n    if (isMomentumCancel === void 0) {\n      isMomentumCancel = false;\n    }\n\n    if (!state.isStarted) return;\n\n    if (state.isMomentum && isMomentumCancel) {\n      publishWheel({\n        isEnding: true,\n        isMomentumCancel: true\n      });\n    } else {\n      publishWheel({\n        isEnding: true\n      });\n    }\n\n    state.isMomentum = false;\n    state.isStarted = false;\n  };\n\n  var _WheelTargetObserver = WheelTargetObserver(feedWheel),\n      observe = _WheelTargetObserver.observe,\n      unobserve = _WheelTargetObserver.unobserve,\n      disconnect = _WheelTargetObserver.disconnect;\n\n  updateOptions(optionsParam);\n  return deepFreeze({\n    on: on,\n    off: off,\n    observe: observe,\n    unobserve: unobserve,\n    disconnect: disconnect,\n    feedWheel: feedWheel,\n    updateOptions: updateOptions\n  });\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WheelGestures);\n\n//# sourceMappingURL=wheel-gestures.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2hlZWwtZ2VzdHVyZXMvZGlzdC93aGVlbC1nZXN0dXJlcy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEtBQUs7QUFDTCxH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Y2VzIjpbIndlYnBhY2s6Ly9oci1hbmFseXRpY3MvLi9ub2RlX21vZHVsZXMvd2hlZWwtZ2VzdHVyZXMvZGlzdC93aGVlbC1nZXN0dXJlcy5lc20uanM/NmQzNiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgREVDQVkgPSAwLjk5Njtcbi8qKlxyXG4gKiBtb3ZlbWVudCBwcm9qZWN0aW9uIGJhc2VkIG9uIHZlbG9jaXR5XHJcbiAqIEBwYXJhbSB2ZWxvY2l0eVB4TXNcclxuICogQHBhcmFtIGRlY2F5XHJcbiAqL1xuXG52YXIgcHJvamVjdGlvbiA9IGZ1bmN0aW9uIHByb2plY3Rpb24odmVsb2NpdHlQeE1zLCBkZWNheSkge1xuICBpZiAoZGVjYXkgPT09IHZvaWQgMCkge1xuICAgIGRlY2F5ID0gREVDQVk7XG4gIH1cblxuICByZXR1cm4gdmVsb2NpdHlQeE1zICogZGVjYXkgLyAoMSAtIGRlY2F5KTtcbn07XG5cbmZ1bmN0aW9uIGxhc3RPZihhcnJheSkge1xuICByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBhdmVyYWdlKG51bWJlcnMpIHtcbiAgcmV0dXJuIG51bWJlcnMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9KSAvIG51bWJlcnMubGVuZ3RoO1xufVxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbHVlKSwgbWF4KTtcbn07XG5mdW5jdGlvbiBhZGRWZWN0b3JzKHYxLCB2Mikge1xuICBpZiAodjEubGVuZ3RoICE9PSB2Mi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlY3RvcnMgbXVzdCBiZSBzYW1lIGxlbmd0aCcpO1xuICB9XG5cbiAgcmV0dXJuIHYxLm1hcChmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgcmV0dXJuIHZhbCArIHYyW2ldO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFic01heChudW1iZXJzKSB7XG4gIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBudW1iZXJzLm1hcChNYXRoLmFicykpO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuXG5mdW5jdGlvbiBkZWVwRnJlZXplKG8pIHtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcbiAgT2JqZWN0LnZhbHVlcyhvKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFPYmplY3QuaXNGcm96ZW4odmFsdWUpKSB7XG4gICAgICBkZWVwRnJlZXplKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gRXZlbnRCdXMoKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcblxuICBmdW5jdGlvbiBvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGxpc3RlbmVyc1t0eXBlXSA9IChsaXN0ZW5lcnNbdHlwZV0gfHwgW10pLmNvbmNhdChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvZmYodHlwZSwgbGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBvZmYodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcnNbdHlwZV0gPSAobGlzdGVuZXJzW3R5cGVdIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24gKGwpIHtcbiAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoISh0eXBlIGluIGxpc3RlbmVycykpIHJldHVybjtcbiAgICBsaXN0ZW5lcnNbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgcmV0dXJuIGwoZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGVlcEZyZWV6ZSh7XG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICB9KTtcbn1cblxuZnVuY3Rpb24gV2hlZWxUYXJnZXRPYnNlcnZlcihldmVudExpc3RlbmVyKSB7XG4gIHZhciB0YXJnZXRzID0gW107IC8vIGFkZCBldmVudCBsaXN0ZW5lciB0byB0YXJnZXQgZWxlbWVudFxuXG4gIHZhciBvYnNlcnZlID0gZnVuY3Rpb24gb2JzZXJ2ZSh0YXJnZXQpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBldmVudExpc3RlbmVyLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdW5vYnNlcnZlKHRhcmdldCk7XG4gICAgfTtcbiAgfTsgLy8vIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tIHRhcmdldCBlbGVtZW50XG5cblxuICB2YXIgdW5vYnNlcnZlID0gZnVuY3Rpb24gdW5vYnNlcnZlKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIGV2ZW50TGlzdGVuZXIpO1xuICAgIHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHQgIT09IHRhcmdldDtcbiAgICB9KTtcbiAgfTsgLy8gc3RvcHMgd2F0Y2hpbmcgYWxsIG9mIGl0cyB0YXJnZXQgZWxlbWVudHMgZm9yIHZpc2liaWxpdHkgY2hhbmdlcy5cblxuXG4gIHZhciBkaXNjb25uZWN0ID0gZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICB0YXJnZXRzLmZvckVhY2godW5vYnNlcnZlKTtcbiAgfTtcblxuICByZXR1cm4gZGVlcEZyZWV6ZSh7XG4gICAgb2JzZXJ2ZTogb2JzZXJ2ZSxcbiAgICB1bm9ic2VydmU6IHVub2JzZXJ2ZSxcbiAgICBkaXNjb25uZWN0OiBkaXNjb25uZWN0XG4gIH0pO1xufVxuXG52YXIgTElORV9IRUlHSFQgPSAxNiAqIDEuMTI1O1xudmFyIFBBR0VfSEVJR0hUID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmlubmVySGVpZ2h0IHx8IDgwMDtcbnZhciBERUxUQV9NT0RFX1VOSVQgPSBbMSwgTElORV9IRUlHSFQsIFBBR0VfSEVJR0hUXTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVdoZWVsKGUpIHtcbiAgdmFyIGRlbHRhWCA9IGUuZGVsdGFYICogREVMVEFfTU9ERV9VTklUW2UuZGVsdGFNb2RlXTtcbiAgdmFyIGRlbHRhWSA9IGUuZGVsdGFZICogREVMVEFfTU9ERV9VTklUW2UuZGVsdGFNb2RlXTtcbiAgdmFyIGRlbHRhWiA9IChlLmRlbHRhWiB8fCAwKSAqIERFTFRBX01PREVfVU5JVFtlLmRlbHRhTW9kZV07XG4gIHJldHVybiB7XG4gICAgdGltZVN0YW1wOiBlLnRpbWVTdGFtcCxcbiAgICBheGlzRGVsdGE6IFtkZWx0YVgsIGRlbHRhWSwgZGVsdGFaXVxuICB9O1xufVxudmFyIHJldmVyc2VBbGwgPSBbLTEsIC0xLCAtMV07XG5mdW5jdGlvbiByZXZlcnNlQXhpc0RlbHRhU2lnbih3aGVlbCwgcmV2ZXJzZVNpZ24pIHtcbiAgaWYgKCFyZXZlcnNlU2lnbikge1xuICAgIHJldHVybiB3aGVlbDtcbiAgfVxuXG4gIHZhciBtdWx0aXBsaWVycyA9IHJldmVyc2VTaWduID09PSB0cnVlID8gcmV2ZXJzZUFsbCA6IHJldmVyc2VTaWduLm1hcChmdW5jdGlvbiAoc2hvdWxkUmV2ZXJzZSkge1xuICAgIHJldHVybiBzaG91bGRSZXZlcnNlID8gLTEgOiAxO1xuICB9KTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCB3aGVlbCwge1xuICAgIGF4aXNEZWx0YTogd2hlZWwuYXhpc0RlbHRhLm1hcChmdW5jdGlvbiAoZGVsdGEsIGkpIHtcbiAgICAgIHJldHVybiBkZWx0YSAqIG11bHRpcGxpZXJzW2ldO1xuICAgIH0pXG4gIH0pO1xufVxudmFyIERFTFRBX01BWF9BQlMgPSA3MDA7XG52YXIgY2xhbXBBeGlzRGVsdGEgPSBmdW5jdGlvbiBjbGFtcEF4aXNEZWx0YSh3aGVlbCkge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIHdoZWVsLCB7XG4gICAgYXhpc0RlbHRhOiB3aGVlbC5heGlzRGVsdGEubWFwKGZ1bmN0aW9uIChkZWx0YSkge1xuICAgICAgcmV0dXJuIGNsYW1wKGRlbHRhLCAtREVMVEFfTUFYX0FCUywgREVMVEFfTUFYX0FCUyk7XG4gICAgfSlcbiAgfSk7XG59O1xuXG52YXIgX19ERVZfXyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG52YXIgQUNDX0ZBQ1RPUl9NSU4gPSAwLjY7XG52YXIgQUNDX0ZBQ1RPUl9NQVggPSAwLjk2O1xudmFyIFdIRUVMRVZFTlRTX1RPX01FUkdFID0gMjtcbnZhciBXSEVFTEVWRU5UU19UT19BTkFMQVpFID0gNTtcblxudmFyIGNvbmZpZ0RlZmF1bHRzID0gLyojX19QVVJFX18qL2RlZXBGcmVlemUoe1xuICBwcmV2ZW50V2hlZWxBY3Rpb246IHRydWUsXG4gIHJldmVyc2VTaWduOiBbdHJ1ZSwgdHJ1ZSwgZmFsc2VdXG59KTtcblxudmFyIFdJTExfRU5EX1RJTUVPVVRfREVGQVVMVCA9IDQwMDtcbmZ1bmN0aW9uIGNyZWF0ZVdoZWVsR2VzdHVyZXNTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBpc1N0YXJ0ZWQ6IGZhbHNlLFxuICAgIGlzU3RhcnRQdWJsaXNoZWQ6IGZhbHNlLFxuICAgIGlzTW9tZW50dW06IGZhbHNlLFxuICAgIHN0YXJ0VGltZTogMCxcbiAgICBsYXN0QWJzRGVsdGE6IEluZmluaXR5LFxuICAgIGF4aXNNb3ZlbWVudDogWzAsIDAsIDBdLFxuICAgIGF4aXNWZWxvY2l0eTogWzAsIDAsIDBdLFxuICAgIGFjY2VsZXJhdGlvbkZhY3RvcnM6IFtdLFxuICAgIHNjcm9sbFBvaW50czogW10sXG4gICAgc2Nyb2xsUG9pbnRzVG9NZXJnZTogW10sXG4gICAgd2lsbEVuZFRpbWVvdXQ6IFdJTExfRU5EX1RJTUVPVVRfREVGQVVMVFxuICB9O1xufVxuXG5mdW5jdGlvbiBXaGVlbEdlc3R1cmVzKG9wdGlvbnNQYXJhbSkge1xuICBpZiAob3B0aW9uc1BhcmFtID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zUGFyYW0gPSB7fTtcbiAgfVxuXG4gIHZhciBfRXZlbnRCdXMgPSBFdmVudEJ1cygpLFxuICAgICAgb24gPSBfRXZlbnRCdXMub24sXG4gICAgICBvZmYgPSBfRXZlbnRCdXMub2ZmLFxuICAgICAgZGlzcGF0Y2ggPSBfRXZlbnRCdXMuZGlzcGF0Y2g7XG5cbiAgdmFyIGNvbmZpZyA9IGNvbmZpZ0RlZmF1bHRzO1xuICB2YXIgc3RhdGUgPSBjcmVhdGVXaGVlbEdlc3R1cmVzU3RhdGUoKTtcbiAgdmFyIGN1cnJlbnRFdmVudDtcbiAgdmFyIG5lZ2F0aXZlWmVyb0ZpbmdlclVwU3BlY2lhbEV2ZW50ID0gZmFsc2U7XG4gIHZhciBwcmV2V2hlZWxFdmVudFN0YXRlO1xuXG4gIHZhciBmZWVkV2hlZWwgPSBmdW5jdGlvbiBmZWVkV2hlZWwod2hlZWxFdmVudHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh3aGVlbEV2ZW50cykpIHtcbiAgICAgIHdoZWVsRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKHdoZWVsRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NXaGVlbEV2ZW50RGF0YSh3aGVlbEV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzV2hlZWxFdmVudERhdGEod2hlZWxFdmVudHMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobmV3T3B0aW9ucykge1xuICAgIGlmIChuZXdPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG5ld09wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhuZXdPcHRpb25zKS5zb21lKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgIHJldHVybiBvcHRpb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb24gPT09IG51bGw7XG4gICAgfSkpIHtcbiAgICAgIF9fREVWX18gJiYgY29uc29sZS5lcnJvcigndXBkYXRlT3B0aW9ucyBpZ25vcmVkISB1bmRlZmluZWQgJiBudWxsIG9wdGlvbnMgbm90IGFsbG93ZWQnKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZyA9IGRlZXBGcmVlemUoX2V4dGVuZHMoe30sIGNvbmZpZ0RlZmF1bHRzLCBjb25maWcsIG5ld09wdGlvbnMpKTtcbiAgfTtcblxuICB2YXIgcHVibGlzaFdoZWVsID0gZnVuY3Rpb24gcHVibGlzaFdoZWVsKGFkZGl0aW9uYWxEYXRhKSB7XG4gICAgdmFyIHdoZWVsRXZlbnRTdGF0ZSA9IF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiBjdXJyZW50RXZlbnQsXG4gICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgIGlzRW5kaW5nOiBmYWxzZSxcbiAgICAgIGlzTW9tZW50dW1DYW5jZWw6IGZhbHNlLFxuICAgICAgaXNNb21lbnR1bTogc3RhdGUuaXNNb21lbnR1bSxcbiAgICAgIGF4aXNEZWx0YTogWzAsIDAsIDBdLFxuICAgICAgYXhpc1ZlbG9jaXR5OiBzdGF0ZS5heGlzVmVsb2NpdHksXG4gICAgICBheGlzTW92ZW1lbnQ6IHN0YXRlLmF4aXNNb3ZlbWVudCxcblxuICAgICAgZ2V0IGF4aXNNb3ZlbWVudFByb2plY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhZGRWZWN0b3JzKHdoZWVsRXZlbnRTdGF0ZS5heGlzTW92ZW1lbnQsIHdoZWVsRXZlbnRTdGF0ZS5heGlzVmVsb2NpdHkubWFwKGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uKHZlbG9jaXR5KTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgfSwgYWRkaXRpb25hbERhdGEpO1xuXG4gICAgZGlzcGF0Y2goJ3doZWVsJywgX2V4dGVuZHMoe30sIHdoZWVsRXZlbnRTdGF0ZSwge1xuICAgICAgcHJldmlvdXM6IHByZXZXaGVlbEV2ZW50U3RhdGVcbiAgICB9KSk7IC8vIGtlZXAgcmVmZXJlbmNlIHdpdGhvdXQgcHJldmlvdXMsIG90aGVyd2lzZSB3ZSB3b3VsZCBjcmVhdGUgYSBsb25nIGNoYWluXG5cbiAgICBwcmV2V2hlZWxFdmVudFN0YXRlID0gd2hlZWxFdmVudFN0YXRlO1xuICB9OyAvLyBzaG91bGQgcHJldmVudCB3aGVuIHRoZXJlIGlzIG1haW5seSBtb3ZlbWVudCBvbiB0aGUgZGVzaXJlZCBheGlzXG5cblxuICB2YXIgc2hvdWxkUHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YU1heEFicywgYXhpc0RlbHRhKSB7XG4gICAgdmFyIF9jb25maWcgPSBjb25maWcsXG4gICAgICAgIHByZXZlbnRXaGVlbEFjdGlvbiA9IF9jb25maWcucHJldmVudFdoZWVsQWN0aW9uO1xuICAgIHZhciBkZWx0YVggPSBheGlzRGVsdGFbMF0sXG4gICAgICAgIGRlbHRhWSA9IGF4aXNEZWx0YVsxXSxcbiAgICAgICAgZGVsdGFaID0gYXhpc0RlbHRhWzJdO1xuICAgIGlmICh0eXBlb2YgcHJldmVudFdoZWVsQWN0aW9uID09PSAnYm9vbGVhbicpIHJldHVybiBwcmV2ZW50V2hlZWxBY3Rpb247XG5cbiAgICBzd2l0Y2ggKHByZXZlbnRXaGVlbEFjdGlvbikge1xuICAgICAgY2FzZSAneCc6XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhkZWx0YVgpID49IGRlbHRhTWF4QWJzO1xuXG4gICAgICBjYXNlICd5JzpcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKGRlbHRhWSkgPj0gZGVsdGFNYXhBYnM7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgICByZXR1cm4gTWF0aC5hYnMoZGVsdGFaKSA+PSBkZWx0YU1heEFicztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgX19ERVZfXyAmJiBjb25zb2xlLndhcm4oJ3Vuc3VwcG9ydGVkIHByZXZlbnRXaGVlbEFjdGlvbiB2YWx1ZTogJyArIHByZXZlbnRXaGVlbEFjdGlvbiwgJ3dhcm4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcHJvY2Vzc1doZWVsRXZlbnREYXRhID0gZnVuY3Rpb24gcHJvY2Vzc1doZWVsRXZlbnREYXRhKHdoZWVsRXZlbnQpIHtcbiAgICB2YXIgX2NsYW1wQXhpc0RlbHRhID0gY2xhbXBBeGlzRGVsdGEocmV2ZXJzZUF4aXNEZWx0YVNpZ24obm9ybWFsaXplV2hlZWwod2hlZWxFdmVudCksIGNvbmZpZy5yZXZlcnNlU2lnbikpLFxuICAgICAgICBheGlzRGVsdGEgPSBfY2xhbXBBeGlzRGVsdGEuYXhpc0RlbHRhLFxuICAgICAgICB0aW1lU3RhbXAgPSBfY2xhbXBBeGlzRGVsdGEudGltZVN0YW1wO1xuXG4gICAgdmFyIGRlbHRhTWF4QWJzID0gYWJzTWF4KGF4aXNEZWx0YSk7XG5cbiAgICBpZiAod2hlZWxFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzaG91bGRQcmV2ZW50RGVmYXVsdChkZWx0YU1heEFicywgYXhpc0RlbHRhKSkge1xuICAgICAgd2hlZWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICghc3RhdGUuaXNTdGFydGVkKSB7XG4gICAgICBzdGFydCgpO1xuICAgIH0gLy8gY2hlY2sgaWYgdXNlciBzdGFydGVkIHNjcm9sbGluZyBhZ2FpbiAtPiBjYW5jZWxcbiAgICBlbHNlIGlmIChzdGF0ZS5pc01vbWVudHVtICYmIGRlbHRhTWF4QWJzID4gTWF0aC5tYXgoMiwgc3RhdGUubGFzdEFic0RlbHRhICogMikpIHtcbiAgICAgICAgZW5kKHRydWUpO1xuICAgICAgICBzdGFydCgpO1xuICAgICAgfSAvLyBzcGVjaWFsIGZpbmdlciB1cCBldmVudCBvbiB3aW5kb3dzICsgYmxpbmtcblxuXG4gICAgaWYgKGRlbHRhTWF4QWJzID09PSAwICYmIE9iamVjdC5pcyAmJiBPYmplY3QuaXMod2hlZWxFdmVudC5kZWx0YVgsIC0wKSkge1xuICAgICAgbmVnYXRpdmVaZXJvRmluZ2VyVXBTcGVjaWFsRXZlbnQgPSB0cnVlOyAvLyByZXR1cm4gLT4gemVybyBkZWx0YSBldmVudCBzaG91bGQgbm90IGluZmx1ZW5jZSB2ZWxvY2l0eVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudEV2ZW50ID0gd2hlZWxFdmVudDtcbiAgICBzdGF0ZS5heGlzTW92ZW1lbnQgPSBhZGRWZWN0b3JzKHN0YXRlLmF4aXNNb3ZlbWVudCwgYXhpc0RlbHRhKTtcbiAgICBzdGF0ZS5sYXN0QWJzRGVsdGEgPSBkZWx0YU1heEFicztcbiAgICBzdGF0ZS5zY3JvbGxQb2ludHNUb01lcmdlLnB1c2goe1xuICAgICAgYXhpc0RlbHRhOiBheGlzRGVsdGEsXG4gICAgICB0aW1lU3RhbXA6IHRpbWVTdGFtcFxuICAgIH0pO1xuICAgIG1lcmdlU2Nyb2xsUG9pbnRzQ2FsY1ZlbG9jaXR5KCk7IC8vIG9ubHkgd2hlZWwgZXZlbnQgKG1vdmUpIGFuZCBub3Qgc3RhcnQvZW5kIGdldCB0aGUgZGVsdGEgdmFsdWVzXG5cbiAgICBwdWJsaXNoV2hlZWwoe1xuICAgICAgYXhpc0RlbHRhOiBheGlzRGVsdGEsXG4gICAgICBpc1N0YXJ0OiAhc3RhdGUuaXNTdGFydFB1Ymxpc2hlZFxuICAgIH0pOyAvLyBzdGF0ZS5pc01vbWVudHVtID8gTU9NRU5UVU1fV0hFRUwgOiBXSEVFTCwgeyBheGlzRGVsdGEgfSlcbiAgICAvLyBwdWJsaXNoIHN0YXJ0IGFmdGVyIHZlbG9jaXR5IGV0Yy4gaGF2ZSBiZWVuIHVwZGF0ZWRcblxuICAgIHN0YXRlLmlzU3RhcnRQdWJsaXNoZWQgPSB0cnVlOyAvLyBjYWxjIGRlYm91bmNlZCBlbmQgZnVuY3Rpb24sIHRvIHJlY29nbml6ZSBlbmQgb2Ygd2hlZWwgZXZlbnQgc3RyZWFtXG5cbiAgICB3aWxsRW5kKCk7XG4gIH07XG5cbiAgdmFyIG1lcmdlU2Nyb2xsUG9pbnRzQ2FsY1ZlbG9jaXR5ID0gZnVuY3Rpb24gbWVyZ2VTY3JvbGxQb2ludHNDYWxjVmVsb2NpdHkoKSB7XG4gICAgaWYgKHN0YXRlLnNjcm9sbFBvaW50c1RvTWVyZ2UubGVuZ3RoID09PSBXSEVFTEVWRU5UU19UT19NRVJHRSkge1xuICAgICAgc3RhdGUuc2Nyb2xsUG9pbnRzLnVuc2hpZnQoe1xuICAgICAgICBheGlzRGVsdGFTdW06IHN0YXRlLnNjcm9sbFBvaW50c1RvTWVyZ2UubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuIGIuYXhpc0RlbHRhO1xuICAgICAgICB9KS5yZWR1Y2UoYWRkVmVjdG9ycyksXG4gICAgICAgIHRpbWVTdGFtcDogYXZlcmFnZShzdGF0ZS5zY3JvbGxQb2ludHNUb01lcmdlLm1hcChmdW5jdGlvbiAoYikge1xuICAgICAgICAgIHJldHVybiBiLnRpbWVTdGFtcDtcbiAgICAgICAgfSkpXG4gICAgICB9KTsgLy8gb25seSB1cGRhdGUgdmVsb2NpdHkgYWZ0ZXIgYSBtZXJnZWQgc2Nyb2xscG9pbnQgd2FzIGdlbmVyYXRlZFxuXG4gICAgICB1cGRhdGVWZWxvY2l0eSgpOyAvLyByZXNldCB0b01lcmdlIGFycmF5XG5cbiAgICAgIHN0YXRlLnNjcm9sbFBvaW50c1RvTWVyZ2UubGVuZ3RoID0gMDsgLy8gYWZ0ZXIgY2FsY3VsYXRpb24gb2YgdmVsb2NpdHkgb25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBtZXJnZWQgc2Nyb2xsUG9pbnRcblxuICAgICAgc3RhdGUuc2Nyb2xsUG9pbnRzLmxlbmd0aCA9IDE7XG5cbiAgICAgIGlmICghc3RhdGUuaXNNb21lbnR1bSkge1xuICAgICAgICBkZXRlY3RNb21lbnR1bSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0YXRlLmlzU3RhcnRQdWJsaXNoZWQpIHtcbiAgICAgIHVwZGF0ZVN0YXJ0VmVsb2NpdHkoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVN0YXJ0VmVsb2NpdHkgPSBmdW5jdGlvbiB1cGRhdGVTdGFydFZlbG9jaXR5KCkge1xuICAgIHN0YXRlLmF4aXNWZWxvY2l0eSA9IGxhc3RPZihzdGF0ZS5zY3JvbGxQb2ludHNUb01lcmdlKS5heGlzRGVsdGEubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZCAvIHN0YXRlLndpbGxFbmRUaW1lb3V0O1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB1cGRhdGVWZWxvY2l0eSA9IGZ1bmN0aW9uIHVwZGF0ZVZlbG9jaXR5KCkge1xuICAgIC8vIG5lZWQgdG8gaGF2ZSB0d28gcmVjZW50IHBvaW50cyB0byBjYWxjIHZlbG9jaXR5XG4gICAgdmFyIF9zdGF0ZSRzY3JvbGxQb2ludHMgPSBzdGF0ZS5zY3JvbGxQb2ludHMsXG4gICAgICAgIGxhdGVzdFNjcm9sbFBvaW50ID0gX3N0YXRlJHNjcm9sbFBvaW50c1swXSxcbiAgICAgICAgcHJldlNjcm9sbFBvaW50ID0gX3N0YXRlJHNjcm9sbFBvaW50c1sxXTtcblxuICAgIGlmICghcHJldlNjcm9sbFBvaW50IHx8ICFsYXRlc3RTY3JvbGxQb2ludCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdGltZSBkZWx0YVxuXG5cbiAgICB2YXIgZGVsdGFUaW1lID0gbGF0ZXN0U2Nyb2xsUG9pbnQudGltZVN0YW1wIC0gcHJldlNjcm9sbFBvaW50LnRpbWVTdGFtcDtcblxuICAgIGlmIChkZWx0YVRpbWUgPD0gMCkge1xuICAgICAgX19ERVZfXyAmJiBjb25zb2xlLndhcm4oJ2ludmFsaWQgZGVsdGFUaW1lJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYWxjIHRoZSB2ZWxvY2l0eSBwZXIgYXhlc1xuXG5cbiAgICB2YXIgdmVsb2NpdHkgPSBsYXRlc3RTY3JvbGxQb2ludC5heGlzRGVsdGFTdW0ubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZCAvIGRlbHRhVGltZTtcbiAgICB9KTsgLy8gY2FsYyB0aGUgYWNjZWxlcmF0aW9uIGZhY3RvciBwZXIgYXhpc1xuXG4gICAgdmFyIGFjY2VsZXJhdGlvbkZhY3RvciA9IHZlbG9jaXR5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIHYgLyAoc3RhdGUuYXhpc1ZlbG9jaXR5W2ldIHx8IDEpO1xuICAgIH0pO1xuICAgIHN0YXRlLmF4aXNWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIHN0YXRlLmFjY2VsZXJhdGlvbkZhY3RvcnMucHVzaChhY2NlbGVyYXRpb25GYWN0b3IpO1xuICAgIHVwZGF0ZVdpbGxFbmRUaW1lb3V0KGRlbHRhVGltZSk7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVdpbGxFbmRUaW1lb3V0ID0gZnVuY3Rpb24gdXBkYXRlV2lsbEVuZFRpbWVvdXQoZGVsdGFUaW1lKSB7XG4gICAgLy8gdXNlIGN1cnJlbnQgdGltZSBiZXR3ZWVuIGV2ZW50cyByb3VuZGVkIHVwIGFuZCBpbmNyZWFzZWQgYnkgYSBiaXQgYXMgdGltZW91dFxuICAgIHZhciBuZXdUaW1lb3V0ID0gTWF0aC5jZWlsKGRlbHRhVGltZSAvIDEwKSAqIDEwICogMS4yOyAvLyBkb3VibGUgdGhlIHRpbWVvdXQsIHdoZW4gbW9tZW50dW0gd2FzIG5vdCBkZXRlY3RlZCB5ZXRcblxuICAgIGlmICghc3RhdGUuaXNNb21lbnR1bSkge1xuICAgICAgbmV3VGltZW91dCA9IE1hdGgubWF4KDEwMCwgbmV3VGltZW91dCAqIDIpO1xuICAgIH1cblxuICAgIHN0YXRlLndpbGxFbmRUaW1lb3V0ID0gTWF0aC5taW4oMTAwMCwgTWF0aC5yb3VuZChuZXdUaW1lb3V0KSk7XG4gIH07XG5cbiAgdmFyIGFjY2VsZXJhdGlvbkZhY3RvckluTW9tZW50dW1SYW5nZSA9IGZ1bmN0aW9uIGFjY2VsZXJhdGlvbkZhY3RvckluTW9tZW50dW1SYW5nZShhY2NGYWN0b3IpIHtcbiAgICAvLyB3aGVuIG1haW4gYXhpcyBpcyB0aGUgdGhlIG90aGVyIG9uZSBhbmQgdGhlcmUgaXMgbm8gbW92ZW1lbnQvY2hhbmdlIG9uIHRoZSBjdXJyZW50IG9uZVxuICAgIGlmIChhY2NGYWN0b3IgPT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBhY2NGYWN0b3IgPD0gQUNDX0ZBQ1RPUl9NQVggJiYgYWNjRmFjdG9yID49IEFDQ19GQUNUT1JfTUlOO1xuICB9O1xuXG4gIHZhciBkZXRlY3RNb21lbnR1bSA9IGZ1bmN0aW9uIGRldGVjdE1vbWVudHVtKCkge1xuICAgIGlmIChzdGF0ZS5hY2NlbGVyYXRpb25GYWN0b3JzLmxlbmd0aCA+PSBXSEVFTEVWRU5UU19UT19BTkFMQVpFKSB7XG4gICAgICBpZiAobmVnYXRpdmVaZXJvRmluZ2VyVXBTcGVjaWFsRXZlbnQpIHtcbiAgICAgICAgbmVnYXRpdmVaZXJvRmluZ2VyVXBTcGVjaWFsRXZlbnQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoYWJzTWF4KHN0YXRlLmF4aXNWZWxvY2l0eSkgPj0gMC4yKSB7XG4gICAgICAgICAgcmVjb2duaXplZE1vbWVudHVtKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNlbnRBY2NlbGVyYXRpb25GYWN0b3JzID0gc3RhdGUuYWNjZWxlcmF0aW9uRmFjdG9ycy5zbGljZShXSEVFTEVWRU5UU19UT19BTkFMQVpFICogLTEpOyAvLyBjaGVjayByZWNlbnQgYWNjZWxlcmF0aW9uIC8gZGVjZWxlcmF0aW9uIGZhY3RvcnNcbiAgICAgIC8vIGFsbCByZWNlbnQgbmVlZCB0byBtYXRjaCwgaWYgYW55IGRpZCBub3QgbWF0Y2hcblxuICAgICAgdmFyIGRldGVjdGVkTW9tZW50dW0gPSByZWNlbnRBY2NlbGVyYXRpb25GYWN0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChhY2NGYWMpIHtcbiAgICAgICAgLy8gd2hlbiBib3RoIGF4aXMgZGVjZWxlcmF0ZSBleGFjdGx5IGluIHRoZSBzYW1lIHJhdGUgaXQgaXMgdmVyeSBsaWtlbHkgY2F1c2VkIGJ5IG1vbWVudHVtXG4gICAgICAgIHZhciBzYW1lQWNjRmFjID0gISFhY2NGYWMucmVkdWNlKGZ1bmN0aW9uIChmMSwgZjIpIHtcbiAgICAgICAgICByZXR1cm4gZjEgJiYgZjEgPCAxICYmIGYxID09PSBmMiA/IDEgOiAwO1xuICAgICAgICB9KTsgLy8gY2hlY2sgaWYgYWNjZWxlcmF0aW9uIGZhY3RvciBpcyB3aXRoaW4gbW9tZW50dW0gcmFuZ2VcblxuICAgICAgICB2YXIgYm90aEFyZUluUmFuZ2VPclplcm8gPSBhY2NGYWMuZmlsdGVyKGFjY2VsZXJhdGlvbkZhY3RvckluTW9tZW50dW1SYW5nZSkubGVuZ3RoID09PSBhY2NGYWMubGVuZ3RoOyAvLyBvbmUgdGhlIHJlcXVpcmVtZW50cyBtdXN0IGJlIGZ1bGZpbGxlZFxuXG4gICAgICAgIHJldHVybiBzYW1lQWNjRmFjIHx8IGJvdGhBcmVJblJhbmdlT3JaZXJvO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkZXRlY3RlZE1vbWVudHVtKSB7XG4gICAgICAgIHJlY29nbml6ZWRNb21lbnR1bSgpO1xuICAgICAgfSAvLyBvbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGV2ZW50c1xuXG5cbiAgICAgIHN0YXRlLmFjY2VsZXJhdGlvbkZhY3RvcnMgPSByZWNlbnRBY2NlbGVyYXRpb25GYWN0b3JzO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVjb2duaXplZE1vbWVudHVtID0gZnVuY3Rpb24gcmVjb2duaXplZE1vbWVudHVtKCkge1xuICAgIHN0YXRlLmlzTW9tZW50dW0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciBzdGFydCA9IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIHN0YXRlID0gY3JlYXRlV2hlZWxHZXN0dXJlc1N0YXRlKCk7XG4gICAgc3RhdGUuaXNTdGFydGVkID0gdHJ1ZTtcbiAgICBzdGF0ZS5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHByZXZXaGVlbEV2ZW50U3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgbmVnYXRpdmVaZXJvRmluZ2VyVXBTcGVjaWFsRXZlbnQgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgd2lsbEVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd2lsbEVuZElkO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhclRpbWVvdXQod2lsbEVuZElkKTtcbiAgICAgIHdpbGxFbmRJZCA9IHNldFRpbWVvdXQoZW5kLCBzdGF0ZS53aWxsRW5kVGltZW91dCk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBlbmQgPSBmdW5jdGlvbiBlbmQoaXNNb21lbnR1bUNhbmNlbCkge1xuICAgIGlmIChpc01vbWVudHVtQ2FuY2VsID09PSB2b2lkIDApIHtcbiAgICAgIGlzTW9tZW50dW1DYW5jZWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXRlLmlzU3RhcnRlZCkgcmV0dXJuO1xuXG4gICAgaWYgKHN0YXRlLmlzTW9tZW50dW0gJiYgaXNNb21lbnR1bUNhbmNlbCkge1xuICAgICAgcHVibGlzaFdoZWVsKHtcbiAgICAgICAgaXNFbmRpbmc6IHRydWUsXG4gICAgICAgIGlzTW9tZW50dW1DYW5jZWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWJsaXNoV2hlZWwoe1xuICAgICAgICBpc0VuZGluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGUuaXNNb21lbnR1bSA9IGZhbHNlO1xuICAgIHN0YXRlLmlzU3RhcnRlZCA9IGZhbHNlO1xuICB9O1xuXG4gIHZhciBfV2hlZWxUYXJnZXRPYnNlcnZlciA9IFdoZWVsVGFyZ2V0T2JzZXJ2ZXIoZmVlZFdoZWVsKSxcbiAgICAgIG9ic2VydmUgPSBfV2hlZWxUYXJnZXRPYnNlcnZlci5vYnNlcnZlLFxuICAgICAgdW5vYnNlcnZlID0gX1doZWVsVGFyZ2V0T2JzZXJ2ZXIudW5vYnNlcnZlLFxuICAgICAgZGlzY29ubmVjdCA9IF9XaGVlbFRhcmdldE9ic2VydmVyLmRpc2Nvbm5lY3Q7XG5cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zUGFyYW0pO1xuICByZXR1cm4gZGVlcEZyZWV6ZSh7XG4gICAgb246IG9uLFxuICAgIG9mZjogb2ZmLFxuICAgIG9ic2VydmU6IG9ic2VydmUsXG4gICAgdW5vYnNlcnZlOiB1bm9ic2VydmUsXG4gICAgZGlzY29ubmVjdDogZGlzY29ubmVjdCxcbiAgICBmZWVkV2hlZWw6IGZlZWRXaGVlbCxcbiAgICB1cGRhdGVPcHRpb25zOiB1cGRhdGVPcHRpb25zXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBXaGVlbEdlc3R1cmVzO1xuZXhwb3J0IHsgV2hlZWxHZXN0dXJlcywgYWJzTWF4LCBhZGRWZWN0b3JzLCBhdmVyYWdlLCBjbGFtcCwgY29uZmlnRGVmYXVsdHMsIGRlZXBGcmVlemUsIGxhc3RPZiwgcHJvamVjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2hlZWwtZ2VzdHVyZXMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/wheel-gestures/dist/wheel-gestures.esm.js\n");

/***/ })

};
;